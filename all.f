HEX
FE000000 CONSTANT RPI4 
RPI4 200000 + CONSTANT GPIO_ADDR
: '(' [ CHAR ( ] LITERAL ;
: ')' [ CHAR ) ] LITERAL ;
: '"' [ CHAR " ] LITERAL ;
: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;
: WITHIN -ROT OVER <= IF > IF TRUE ELSE FALSE THEN ELSE 2DROP FALSE THEN ;
( utility.f - per inserire i commenti - jonesforth.f )

: C, HERE @ C! 1 HERE +! ;
: ALIGN HERE @ 3 + 3 INVERT AND HERE ! ;
: S" IMMEDIATE STATE @ IF ' LITS , HERE @ 0 ,
	BEGIN KEY DUP '"' <> WHILE C, REPEAT DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN
	ELSE HERE @
	BEGIN KEY DUP '"' <> WHILE OVER C! 1+ REPEAT DROP HERE @ - HERE @ SWAP THEN ;
: ." IMMEDIATE STATE @ 
	IF [COMPILE] S" ' TELL ,
	ELSE BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN THEN ;

: GET @ U. ;
: STACK_CLEAR BEGIN DEPTH 0> WHILE DROP REPEAT ;

( gpio.f )
GPIO_ADDR      CONSTANT GPFSEL0
GPIO_ADDR  4 + CONSTANT GPFSEL1
GPIO_ADDR  8 + CONSTANT GPFSEL2
GPIO_ADDR 10 + CONSTANT GPFSEL4

: 1BIT_SET 1 SWAP LSHIFT ;
: GPIO 1BIT_SET ;
: 2_LSHIFT A MOD 2 * ;
: 3_LSHIFT A MOD 3 * ;
: N_GPIO 0 SWAP BEGIN DUP 2 MOD 0 = IF 1 RSHIFT SWAP 1+ SWAP ELSE THEN DUP 2 = UNTIL DROP 1+ ;
: MASK2 2_LSHIFT 3 SWAP LSHIFT INVERT ;
: MASK3 3_LSHIFT 7 SWAP LSHIFT INVERT ;
: OUT 3_LSHIFT 1BIT_SET ;
: ALT0_FUN 3_LSHIFT 2+ 1BIT_SET ;
: ALT5_FUN 3_LSHIFT 1+ 1BIT_SET ;
: FSEL DUP A / 4 * GPFSEL0 + ;
: FUNCTION FSEL 2DUP SWAP MASK3 SWAP @ AND ROT ;
: INPUT N_GPIO FUNCTION DROP SWAP ! ;
: OUTPUT N_GPIO FUNCTION OUT OR SWAP ! ;
: ALT0 N_GPIO FUNCTION ALT0_FUN OR SWAP ! ;
: ALT5 N_GPIO FUNCTION ALT5_FUN OR SWAP ! ;

DECIMAL
0 GPIO CONSTANT GPIO0 1 GPIO CONSTANT GPIO1 2 GPIO CONSTANT GPIO2 3 GPIO CONSTANT GPIO3
4 GPIO CONSTANT GPIO4 5 GPIO CONSTANT GPIO5 6 GPIO CONSTANT GPIO6 7 GPIO CONSTANT GPIO7
8 GPIO CONSTANT GPIO8 9 GPIO CONSTANT GPIO9 10 GPIO CONSTANT GPIO10 11 GPIO CONSTANT GPIO11
12 GPIO CONSTANT GPIO12 13 GPIO CONSTANT GPIO13 14 GPIO CONSTANT GPIO14 15 GPIO CONSTANT GPIO15
16 GPIO CONSTANT GPIO16 17 GPIO CONSTANT GPIO17 18 GPIO CONSTANT GPIO18 19 GPIO CONSTANT GPIO19
20 GPIO CONSTANT GPIO20 21 GPIO CONSTANT GPIO21 22 GPIO CONSTANT GPIO22 23 GPIO CONSTANT GPIO23
24 GPIO CONSTANT GPIO24 25 GPIO CONSTANT GPIO25 26 GPIO CONSTANT GPIO26 27 GPIO CONSTANT GPIO27
10 GPIO CONSTANT GPIO42
HEX

( timer.f )
RPI4 3000 + CONSTANT TIMER 
TIMER       CONSTANT TIMER_CONTROL_STATUS
TIMER  04 + CONSTANT TIMER_COUNTER_LOW

: NOW TIMER_COUNTER_LOW @ ;
: DELAY NOW + BEGIN DUP NOW - 0 <= UNTIL DROP ;
: MSEC 3E8 * ;
: 0.5SEC 1F4 MSEC ;
: SEC 3E8 MSEC * ;

( led.f )
GPIO_ADDR 1C + CONSTANT GPSET0
GPIO_ADDR 20 + CONSTANT GPSET1
GPIO_ADDR 28 + CONSTANT GPCLR0
GPIO_ADDR 2C + CONSTANT GPCLR1
GPIO_ADDR 34 + CONSTANT GPLEV0

GPIO13 OUTPUT GPIO16 OUTPUT GPIO26 OUTPUT
GPIO13 CONSTANT RED
GPIO16 CONSTANT YELLOW
GPIO26 CONSTANT GREEN

: LED GPSET0 GPCLR0 ;
: LED42 GPIO42 GPSET1 GPCLR1 ;
: ON DROP ! ;
: OFF NIP ! ;
: HIGH LED ON ;
: LOW LED OFF ;
: IS_ON GPLEV0 @ AND 0 = IF 0 ELSE 1 THEN ;
: BLINK 2DUP LED ON DELAY LED OFF DELAY ;

( event.f )
GPIO_ADDR 40 + CONSTANT GPEDS0
GPIO_ADDR 4C + CONSTANT GPREN0
GPIO_ADDR 58 + CONSTANT GPFEN0
GPIO_ADDR 7C + CONSTANT GPAREN0
GPIO_ADDR 88 + CONSTANT GPAFEN0

: ENABLE TUCK @ OR SWAP ! ;
: DISABLE SWAP INVERT OVER @ AND SWAP ! ;
: CLEAR_EVENT GPEDS0 ENABLE ;

( button.f )
GPIO_ADDR E4 + CONSTANT GPIO_PUP_PDN_0
: PULL_UP N_GPIO GPIO_PUP_PDN_0 2DUP SWAP MASK2 SWAP @ AND ROT 2_LSHIFT 1BIT_SET OR SWAP ! ;
: PULL_DOWN N_GPIO GPIO_PUP_PDN_0 2DUP SWAP MASK2 SWAP @ AND ROT 2_LSHIFT 1+ 1BIT_SET OR SWAP ! ;
GPIO9 PULL_UP
GPIO9 CONSTANT BREAK_BUTTON
BREAK_BUTTON GPREN0 ENABLE
BREAK_BUTTON CLEAR_EVENT
: IS_PRESSED GPLEV0 @ AND 0 = IF 1 ELSE 0 THEN ;
: IS_CLICKED GPEDS0 @ AND 0 = IF 0 ELSE 1 THEN ;

( pir.f )
GPIO12 OUTPUT
GPIO12 CONSTANT BUZZER
GPIO27 CONSTANT PIR
PIR GPREN0 ENABLE
PIR CLEAR_EVENT

: IS_HIGH IS_ON ;
: BLINK_BUZ 2DUP LED ON BUZZER HIGH DELAY LED OFF BUZZER LOW DELAY ;
: MOTION_DETECTED GPEDS0 @ AND 0 = IF 0 ELSE 1 THEN ;
: DELAY_COUNTER 0 ;

: PIR_CALIBRATION
	BEGIN 
		PIR IS_HIGH 0 = IF 1 SEC DELAY YELLOW LED OFF ." Nessun movimento" CR
		ELSE YELLOW LED ON ." Pir High" CR DELAY_COUNTER
			BEGIN PIR IS_HIGH WHILE 1 SEC DELAY 1+ DUP . ." sec " REPEAT CR
		THEN 1 SEC DELAY YELLOW LED OFF ." Pir Low" CR
        DEPTH 0> IF ." Durata totale: " . ." secondi" CR 1 SEC DELAY THEN
	BREAK_BUTTON IS_CLICKED UNTIL 
	BREAK_BUTTON CLEAR_EVENT ;

: MOTION_DETECTION
    BEGIN 
        PIR DUP MOTION_DETECTED IF
            CLEAR_EVENT ." Movimento rilevato" CR
            BEGIN PIR IS_HIGH WHILE 0.5SEC RED BLINK_BUZ REPEAT
        ELSE 
            RED LED OFF CLEAR_EVENT ." Nessun movimento" CR 1 SEC DELAY 
        THEN
    BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;

( sonar.f )
GPIO4 OUTPUT
GPIO17 INPUT
GPIO4 CONSTANT TRIGGER_PIN
GPIO17 CONSTANT ECHO_PIN
ECHO_PIN GPREN0 ENABLE
ECHO_PIN GPFEN0 ENABLE

: TIME_OUT 5 A * MSEC DELAY ;
: SEND_TIME A MSEC DELAY ;
: TRIGGER TRIGGER_PIN HIGH SEND_TIME TRIGGER_PIN LOW ;
: LEDS_OFF RED LED OFF YELLOW LED OFF GREEN LED OFF BUZZER LOW ;

: DISTANCE_CHECK
    BEGIN
    DEPTH 4 < WHILE
        ECHO_PIN IS_HIGH IF TIME_OUT DELAY THEN TRIGGER
        BEGIN ECHO_PIN IS_HIGH 0 = WHILE ." ." REPEAT NOW
        BEGIN ECHO_PIN IS_HIGH WHILE ." -" REPEAT NOW
    REPEAT
    DEPTH 4 = IF SWAP - 154 * 2 / 1 MSEC / -ROT SWAP - 154 * 2 / 1 MSEC /
        2DUP < IF DROP ELSE NIP THEN . CR
    ELSE STACK_CLEAR THEN ;

: DISTANCE_DETECTION
    BEGIN
    DEPTH 4 < WHILE
        ECHO_PIN IS_HIGH IF TIME_OUT DELAY THEN
        TRIGGER
        BEGIN ECHO_PIN IS_HIGH 0 = WHILE REPEAT
        NOW
        BEGIN ECHO_PIN IS_HIGH WHILE REPEAT
        NOW
    REPEAT
    DEPTH 4 = IF
        SWAP - 154 * 2 / 1 MSEC / -ROT
        SWAP - 154 * 2 / 1 MSEC /
        2DUP < IF DROP ELSE NIP THEN . CR
    ELSE STACK_CLEAR THEN
;
: ALERT BEGIN BUZZER HIGH BREAK_BUTTON IS_CLICKED UNTIL QUIT ;
: DISTANCE_LED_DETECTION
    1 SEC DELAY
    LEDS_OFF
    BEGIN
    DEPTH 4 < WHILE 
		ECHO_PIN IS_HIGH IF TIME_OUT DELAY THEN TRIGGER
        BEGIN ECHO_PIN IS_HIGH 0 = WHILE REPEAT NOW
        BEGIN ECHO_PIN IS_HIGH WHILE REPEAT NOW
    REPEAT
    DEPTH 4 = IF 
        SWAP - 154 * 2 / 1 MSEC / -ROT
        SWAP - 154 * 2 / 1 MSEC /
        2DUP < IF DROP ELSE NIP THEN DUP . ." mm " CR
            DUP 5A < IF ALERT THEN 
            DUP 5A C8 WITHIN IF RED LED ON BUZZER HIGH THEN
            DUP C8 190 WITHIN IF YELLOW LED ON THEN
            DUP 190 > IF GREEN LED ON THEN
     ELSE STACK_CLEAR LEDS_OFF THEN ;


: SONAR_CHECK BEGIN 1 SEC DELAY DISTANCE_CHECK BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;
: SONAR_DETECTION BEGIN 1 SEC DELAY DISTANCE_DETECTION BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;
: SONAR_LED BEGIN 1 SEC DELAY DISTANCE_LED_DETECTION BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;

: SECURITY_SYSTEM
	BEGIN 
		PIR DUP MOTION_DETECTED IF CLEAR_EVENT ." Movimento rilevato" CR
			BEGIN PIR IS_HIGH WHILE DISTANCE_LED_DETECTION REPEAT
		ELSE LEDS_OFF CLEAR_EVENT ." Nessun movimento" CR 1 SEC DELAY THEN
	BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;

( sicurezza.f )
GPIO5 CONSTANT BUTTON5
GPIO6 CONSTANT BUTTON6
GPIO7 CONSTANT BUTTON7
GPIO8 CONSTANT BUTTON8

BUTTON5 GPREN0 ENABLE
BUTTON6 GPREN0 ENABLE
BUTTON7 GPREN0 ENABLE
BUTTON8 GPREN0 ENABLE

: BUTTONS_RESET BUTTON5 BUTTON6 OR BUTTON7 OR BUTTON8 OR CLEAR_EVENT ;

: SEQUENZA 8 = -ROT 6 = -ROT 5 = -ROT 2SWAP SWAP 7 = ; ( ordine 7 5 6 8 )
: RESET STACK_CLEAR
        GPEDS0 @ 0<> IF
        BUTTONS_RESET THEN
;

: PIN_CHECK
    BEGIN
        RESET  
        ." DIGITA IL PIN E PREMI INVIO "
        BEGIN
            1 SEC DELAY

            BUTTON7 IS_CLICKED IF
            ." 7 " BUTTON7 N_GPIO BUTTON7 CLEAR_EVENT THEN

            BUTTON5 IS_CLICKED IF
            ." 5 " BUTTON5 N_GPIO BUTTON5 CLEAR_EVENT THEN 

            BUTTON6 IS_CLICKED IF
            ." 6 " BUTTON6 N_GPIO BUTTON6 CLEAR_EVENT THEN

            BUTTON8 IS_CLICKED IF
            ." 8 " BUTTON8 N_GPIO BUTTON8 CLEAR_EVENT THEN

        BREAK_BUTTON IS_CLICKED
        UNTIL
        BREAK_BUTTON CLEAR_EVENT

        0.5SEC YELLOW BLINK

        DEPTH 4 <> IF
            STACK_CLEAR
            FALSE
            ." ERRATA " CR
            0.5SEC RED BLINK 
        ELSE
            SEQUENZA
            AND AND AND
            DUP FALSE = IF
                ." ERRATA " CR
                0.5SEC RED BLINK
            THEN 
        THEN 
    TRUE = BREAK_BUTTON IS_CLICKED OR
    UNTIL
    BREAK_BUTTON IS_CLICKED IF
        BREAK_BUTTON CLEAR_EVENT
    ELSE
        1 SEC GREEN BLINK
        ." CORRETTA " CR
        RESET
        1
    THEN
;

: MAIN 
    PIN_CHECK IF
        SECURITY_SYSTEM
    THEN
;