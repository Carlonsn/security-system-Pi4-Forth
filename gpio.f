( gpio.f )
GPIO_ADDR      CONSTANT GPFSEL0
GPIO_ADDR  4 + CONSTANT GPFSEL1
GPIO_ADDR  8 + CONSTANT GPFSEL2
GPIO_ADDR 10 + CONSTANT GPFSEL4

: 1BIT_SET 1 SWAP LSHIFT ; ( n -- 1<<n  es. 3 1BIT_SET -- 0bx1000)
( per migliorare la leggibilitÃ  del codice )
: GPIO 1BIT_SET ;
( calcola n GPIO a partire dal bit significativo )
: N_GPIO 0 SWAP BEGIN DUP 2 MOD 0 = IF 1 RSHIFT SWAP 1+ SWAP ELSE THEN DUP 2 = UNTIL DROP 1+ ;
: N_LSHIFT A MOD 3 * ; ( n -- 3*q [q = resto della divisione per 10 0xA] )
( maschera da 3 bit ottenuta effettuando uno shift a sinistra di n di 7 )
( 7 in binario 0bx111 con invert tutti 1 tranne 0 nei 3 bit corrispondenti al 7)
: MASK N_LSHIFT 7 SWAP LSHIFT INVERT ; ( es. 13 MASK -- 0b11.111.111_111.111.11_1.111.000.1_11.111.111 -- FFFFF8FF )
: OUT N_LSHIFT 1BIT_SET ;         ( GPFSEL in output - 001 )
: ALT0_FUN N_LSHIFT 2+ 1BIT_SET ; ( GPFSEL in alt0   - 100 )
: ALT5_FUN N_LSHIFT 1+ 1BIT_SET ; ( GPFSEL in alt5   - 010 )
: FSEL DUP A / 4 * GPFSEL0 + ; ( ottengo il registro GPFSEL corrispondente al n GPIO calcolando l'offset = n/10 * 4)
: FUNCTION FSEL 2DUP SWAP MASK SWAP @ AND ROT ;
: INPUT N_GPIO FUNCTION DROP SWAP ! ;
: OUTPUT N_GPIO FUNCTION OUT OR SWAP ! ;
: ALT0 N_GPIO FUNCTION ALT0_FUN OR SWAP ! ;
: ALT5 N_GPIO FUNCTION ALT5_FUN OR SWAP ! ;

DECIMAL
0 GPIO CONSTANT GPIO0
1 GPIO CONSTANT GPIO1
2 GPIO CONSTANT GPIO2
3 GPIO CONSTANT GPIO3
4 GPIO CONSTANT GPIO4
5 GPIO CONSTANT GPIO5
6 GPIO CONSTANT GPIO6
7 GPIO CONSTANT GPIO7
8 GPIO CONSTANT GPIO8
9 GPIO CONSTANT GPIO9
10 GPIO CONSTANT GPIO10
11 GPIO CONSTANT GPIO11
12 GPIO CONSTANT GPIO12
13 GPIO CONSTANT GPIO13
14 GPIO CONSTANT GPIO14
15 GPIO CONSTANT GPIO15
16 GPIO CONSTANT GPIO16
17 GPIO CONSTANT GPIO17
18 GPIO CONSTANT GPIO18
19 GPIO CONSTANT GPIO19
20 GPIO CONSTANT GPIO20
21 GPIO CONSTANT GPIO21
22 GPIO CONSTANT GPIO22
23 GPIO CONSTANT GPIO23
24 GPIO CONSTANT GPIO24
25 GPIO CONSTANT GPIO25
26 GPIO CONSTANT GPIO26
27 GPIO CONSTANT GPIO27
10 GPIO CONSTANT GPIO42
HEX