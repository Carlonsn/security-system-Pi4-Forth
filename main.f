HEX
FE000000 CONSTANT RPI4 
RPI4 200000 + CONSTANT GPIO_ADDR
: '(' [ CHAR ( ] LITERAL ;
: ')' [ CHAR ) ] LITERAL ;
: '"' [ CHAR " ] LITERAL ;
: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;
( utility.f - per inserire i commenti - jonesforth.f )

: C, HERE @ C! 1 HERE +! ;
: ALIGN HERE @ 3 + 3 INVERT AND HERE ! ;
: S" IMMEDIATE STATE @ IF ' LITS , HERE @ 0 ,
	BEGIN KEY DUP '"' <> WHILE C, REPEAT DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN
	ELSE HERE @
	BEGIN KEY DUP '"' <> WHILE OVER C! 1+ REPEAT DROP HERE @ - HERE @ SWAP THEN ;
: ." IMMEDIATE STATE @ 
	IF [COMPILE] S" ' TELL ,
	ELSE BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN THEN ;

: GET @ U. ;
: STACK_CLEAR BEGIN DEPTH 0> WHILE DROP REPEAT ;

( gpio.f )
GPIO_ADDR      CONSTANT GPFSEL0
GPIO_ADDR  4 + CONSTANT GPFSEL1
GPIO_ADDR  8 + CONSTANT GPFSEL2
GPIO_ADDR 10 + CONSTANT GPFSEL4

: 1BIT_SET 1 SWAP LSHIFT ;
: GPIO 1BIT_SET ;
: N_LSHIFT A MOD 3 * ;
: N_GPIO 0 SWAP BEGIN DUP 2 MOD 0 = IF 1 RSHIFT SWAP 1+ SWAP ELSE THEN DUP 2 = UNTIL DROP 1+ ;
: MASK N_LSHIFT 7 SWAP LSHIFT INVERT ;
: OUT N_LSHIFT 1BIT_SET ;
: ALT0_FUN N_LSHIFT 2+ 1BIT_SET ;
: ALT5_FUN N_LSHIFT 1+ 1BIT_SET ;
: FSEL DUP A / 4 * GPFSEL0 + ;
: FUNCTION FSEL 2DUP SWAP MASK SWAP @ AND ROT ;
: INPUT N_GPIO FUNCTION DROP SWAP ! ;
: OUTPUT N_GPIO FUNCTION OUT OR SWAP ! ;
: ALT0 N_GPIO FUNCTION ALT0_FUN OR SWAP ! ;
: ALT5 N_GPIO FUNCTION ALT5_FUN OR SWAP ! ;

DECIMAL
0 GPIO CONSTANT GPIO0 1 GPIO CONSTANT GPIO1 2 GPIO CONSTANT GPIO2 3 GPIO CONSTANT GPIO3
4 GPIO CONSTANT GPIO4 5 GPIO CONSTANT GPIO5 6 GPIO CONSTANT GPIO6 7 GPIO CONSTANT GPIO7
8 GPIO CONSTANT GPIO8 9 GPIO CONSTANT GPIO9 10 GPIO CONSTANT GPIO10 11 GPIO CONSTANT GPIO11
12 GPIO CONSTANT GPIO12 13 GPIO CONSTANT GPIO13 14 GPIO CONSTANT GPIO14 15 GPIO CONSTANT GPIO15
16 GPIO CONSTANT GPIO16 17 GPIO CONSTANT GPIO17 18 GPIO CONSTANT GPIO18 19 GPIO CONSTANT GPIO19
20 GPIO CONSTANT GPIO20 21 GPIO CONSTANT GPIO21 22 GPIO CONSTANT GPIO22 23 GPIO CONSTANT GPIO23
24 GPIO CONSTANT GPIO24 25 GPIO CONSTANT GPIO25 26 GPIO CONSTANT GPIO26 27 GPIO CONSTANT GPIO27
10 GPIO CONSTANT GPIO42
HEX

( timer.f )
RPI4 3000 + CONSTANT TIMER 
TIMER       CONSTANT TIMER_CONTROL_STATUS
TIMER  04 + CONSTANT TIMER_COUNTER_LOW

: NOW TIMER_COUNTER_LOW @ ;
: DELAY NOW + BEGIN DUP NOW - 0 <= UNTIL DROP ;
: MSEC 3E8 * ;
: 0.5SEC 1F4 MSEC ;
: SEC 3E8 MSEC * ;

( led.f )
GPIO_ADDR 1C + CONSTANT GPSET0
GPIO_ADDR 20 + CONSTANT GPSET1
GPIO_ADDR 28 + CONSTANT GPCLR0
GPIO_ADDR 2C + CONSTANT GPCLR1
GPIO_ADDR 34 + CONSTANT GPLEV0

GPIO13 OUTPUT GPIO16 OUTPUT GPIO26 OUTPUT
GPIO13 CONSTANT GREEN
GPIO16 CONSTANT YELLOW
GPIO26 CONSTANT RED

: LED GPSET0 GPCLR0 ;
: LED42 GPIO42 GPSET1 GPCLR1 ;
: ON DROP ! ;
: OFF NIP ! ;
: HIGH LED ON ;
: LOW LED OFF ;
: IS_ON GPLEV0 @ AND 0 = IF 0 ELSE 1 THEN ;
: BLINK 2DUP LED ON DELAY LED OFF DELAY ;

( event.f )
GPIO_ADDR 40 + CONSTANT GPEDS0
GPIO_ADDR 4C + CONSTANT GPREN0
GPIO_ADDR 58 + CONSTANT GPFEN0
GPIO_ADDR 7C + CONSTANT GPAREN0
GPIO_ADDR 88 + CONSTANT GPAFEN0

: ENABLE TUCK @ OR SWAP ! ;
: DISABLE SWAP INVERT OVER @ AND SWAP ! ;
: CLEAR_EVENT GPEDS0 ENABLE ;

( button.f )
GPIO_ADDR E4 + CONSTANT PULLUP
GPIO8 CONSTANT BREAK_BUTTON
BREAK_BUTTON GPREN0 ENABLE
BREAK_BUTTON CLEAR_EVENT
: IS_PRESSED GPLEV0 @ AND 0 = IF 1 ELSE 0 THEN ;
: IS_CLICKED GPEDS0 @ AND 0 = IF 0 ELSE 1 THEN ;
: Y_LED_ON_UNTIL YELLOW ;
: G_LED_ON_UNTIL GREEN ;
: PRESSED BEGIN DUP IS_PRESSED 1 = WHILE OVER LED ON REPEAT OVER LED OFF 2DROP ;

( pir.f )
GPIO12 OUTPUT
GPIO12 CONSTANT BUZZER
GPIO27 CONSTANT PIR
PIR GPREN0 ENABLE
PIR CLEAR_EVENT

: BLINK_BUZ 2DUP LED ON BUZZER HIGH DELAY LED OFF BUZZER LOW DELAY ;
: MOTION_DETECTED GPEDS0 @ AND 0 = IF 0 ELSE 1 THEN ;
: DELAY_COUNTER 0 ;
: PIR_CALIBRATION
	BEGIN 
		PIR IS_ON 0 = IF 1 SEC DELAY YELLOW LED OFF ." Nessun movimento" CR
		ELSE YELLOW LED ON ." Pir High" CR DELAY_COUNTER
			BEGIN PIR IS_ON WHILE 1 SEC DELAY 1+ DUP . ." sec " REPEAT CR
		THEN 1 SEC DELAY YELLOW LED OFF ." Pir Low" CR
        DEPTH 0> IF ." Durata totale: " . ." secondi" CR 5 SEC DELAY THEN
	BREAK_BUTTON IS_CLICKED UNTIL 
	BREAK_BUTTON CLEAR_EVENT ;

: MOTION_DETECTION
BEGIN 
    PIR DUP MOTION_DETECTED IF
         CLEAR_EVENT ." Movimento rilevato" CR
         BEGIN PIR IS_ON WHILE 0.5SEC RED BLINK_BUZ REPEAT
    ELSE 
        RED LED OFF CLEAR_EVENT ." Nessun movimento" CR 5 SEC DELAY 
    THEN
BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;

( sonar.f )
GPIO4 OUTPUT
GPIO17 INPUT
GPIO4 CONSTANT TRIGGER_PIN
GPIO17 CONSTANT ECHO_PIN
ECHO_PIN GPREN0 ENABLE
ECHO_PIN GPFEN0 ENABLE

: TIME_OUT 5 A * MSEC DELAY ;
: SEND_TIME A MSEC DELAY ;
: TRIGGER TRIGGER_PIN HIGH SEND_TIME TRIGGER_PIN LOW ;

: DISTANCE_CHECK
    BEGIN
    DEPTH 2 < WHILE 
		ECHO_PIN IS_ON IF ." waiting for timeout" TIME_OUT DELAY THEN TRIGGER
        BEGIN ECHO_PIN IS_ON 0 = WHILE ." ." REPEAT NOW
        BEGIN ECHO_PIN IS_ON WHILE ." -" REPEAT NOW
    REPEAT
    DEPTH 2 = IF SWAP - 154 * 2 / 1 MSEC / . ELSE STACK_CLEAR THEN ;

: DISTANCE_DETECTION
    BEGIN
    DEPTH 2 < WHILE 
		ECHO_PIN IS_ON IF TIME_OUT DELAY THEN TRIGGER
        BEGIN ECHO_PIN IS_ON 0 = WHILE REPEAT NOW
        BEGIN ECHO_PIN IS_ON WHILE REPEAT NOW
    REPEAT
    DEPTH 2 = IF SWAP - 154 * 2 / 1 MSEC / . ." mm " ELSE STACK_CLEAR THEN CR ;

: SONAR_CHECK BEGIN 1 SEC DELAY DISTANCE_CHECK BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;

: SECURITY_SYSTEM
	BEGIN 
		PIR DUP MOTION_DETECTED IF CLEAR_EVENT ." Movimento rilevato" CR
			BEGIN PIR IS_ON WHILE DISTANCE_DETECTION 0.5SEC RED BLINK_BUZ REPEAT
		ELSE RED LED OFF CLEAR_EVENT ." Nessun movimento" CR 5 SEC DELAY THEN
	BREAK_BUTTON IS_CLICKED UNTIL BREAK_BUTTON CLEAR_EVENT ;
